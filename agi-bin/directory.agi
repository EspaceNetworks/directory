#!/usr/bin/php -q
<?php
error_reporting(1);
set_error_handler("error_handler");

verbose('entered dir!',6);
require_once(dirname(__FILE__).'/directory.lib.php');
$loopcounter1	= 0;
$loopcounter2 	= 0;
$matches		= false;
$matches 		= false;
$needs_welcome 	= true;
$search			= array();
$dir			= new Dir();

while ($loopcounter1 <= $dir->dir['repeat_loops']) {
	//get inital search term
	while ($loopcounter2 <= $dir->dir['repeat_loops'] && !$matches ) {
		//get any number of digits, terminated by timeout or #
    $buffer = '';
	if ($needs_welcome) {
		$needs_welcome = false;
		$search = $dir->agi->fastpass_get_data($buffer, 'cdir-welcome',100,3);
      if ((strlen($buffer) < 3) && (strstr($search['result'],'0') === false)) {
 		$search = $dir->agi->fastpass_get_data($buffer, $dir->dir['announcement'], 3000, 3);
      }
    } else {
		$search = $dir->agi->fastpass_get_data($buffer, $dir->dir['announcement'],3000,3);
    }
		$search = $search['result'];//being set so we can use it later
		$matches = $dir->search($search,1);
		$loopcounter2++;
	}
	//hangup if we failed to receive anything meanigfull
	if ($loopcounter2 == 3) {//seem like we ran out of tries... 
		$dir->agi->stream_file('sorry-youre-having-problems');
    $dir->bail();
		break;
	}
	$matchesloop = 0;
	$matches = $dir->search($search,1);
	//prompt the caller for more info if there are too many results (and he didnt terminate with #)

	while($matches > 1 && $matchesloop < $dir->dir['repeat_loops'] && substr($search,-1)!='#'){
	    if ($matches < 10) {
	      $compound = array('silence/1','cdir-there-are',(integer)$matches,'cdir-matching-entries-or-pound');
	      $validdigits = '1234567890#';
	    } else {
	      // don't allow #, get new recording that indicates such
	      $compound = array('silence/1','cdir-there-are',(integer)$matches,'cdir-matching-entries-continue');
	      $validdigits = '1234567890';
	    }
		  $press = $dir->getKeypress($compound, $validdigits, 3000);
			if (!empty($press['result']) || $press==0) {
				$search .= $press['result'];
				$matches = $dir->search($search,1);
	      if ($matches > 9) {
	        $search = rtrim($search,'#');
	        verbose("Too many found: $matches, remove # if set and try again",6);
	      }
			} else {
				$matchesloop++;
			}
	    // if they timeout and there are 3 or fewer matches then just play them
	    if (empty($press['result']) && $matches <=3) {
	      break;
	    }
	}

	//act based on the amount of matches
	if ($matches > 1 && $matches <= 9) {
		//draw up variable of valid key presses
		$validkeys = '';
		for ($i=1; $i < $matches+1; $i++) {
			$validkeys .= $i;
		}
    	verbose("valid keys for entries are: $validkeys",6);
		
		//playback entries
		$matches = $dir->search($search);
		foreach ($matches as $idx => $match) {
			$ret = $dir->getKeypress('for',$validkeys,0);
			if (trim($ret['result'])) {
				break;
			}
			$ret = $dir->readContact($matches[$idx],$validkeys,0);
			if (trim($ret['result'])) {
				break;
			}
			$ret = $dir->getKeypress('press',$validkeys,0);
			if (trim($ret['result'])) {
				break;
			}
			$ret = $dir->agi->say_digits($idx+1,$validkeys);
			if (trim($ret['result'])) {
				$ret['result'] = chr($ret['result']);
				break;
			}
		}
		//wait for a responce before restarting loop
    	$ret = $dir->agi->wait_for_digit(10000);
		if (trim($ret['result'])) {
			$ret['result'] = chr($ret['result']);
		}
		
		verbose("got result: ".$ret['result'],6);
		if (trim($ret['result'])) {
			call($matches[$ret['result']-1]);
		}
	} elseif ($matches==1) {
		//call person $macthes[0];
		$matches = $dir->search($search);
		call($matches[0]);
	} else {
		$dir->agi->stream_file($dir->dir['repeat_recording']);
		$loopcounter1++;
		$search = $matches = $loopcounter2 = 0;
	}
}

if($loopcounter1){
  $dir->bail();
}

function call($contact){
	global $dir;
	$dir->readContact($contact,$validkeys,0);
	if ($dir->dir['alert_info'] != '') {
		$dir->agi->set_alertinfo($dir->dir['alert_info']);
	}
	if ($dir->dir['callid_prefix'] != '') {
		$dir->agi->set_variable('CALLERID(name)',$dir->dir['callid_prefix'].$dir->dir['calleridname']);
	}
	$dir->agi->set_variable('DIR_DIAL',$contact['dial']);
	exit;
}

//send debug to asterisk cli
function verbose($string, $level=3){
	global $dir;
  $dir->agi->verbose($string, $level);

  // send same message to debug log if enabled
  dbug($string);
}

 /* 
  * FreePBX Debugging function
  * This function can be called as follows:
  * dbug() - will just print a time stamp to the debug log file ($amp_conf['FPBXDBUGFILE'])
  * dbug('string') - same as above + will print the string
  * dbug('string',$array) - same as above + will print_r the array after the message
  * dbug($array) - will print_r the array with no message (just a time stamp)  
  * dbug('string',$array,1) - same as above + will var_dump the array
  * dbug($array,1) - will var_dump the array with no message  (just a time stamp)
  * 	 
 	*/  
function dbug(){
	$opts = func_get_args();

	$dump = 0;
	//sort arguments
	switch (count($opts)) {
		case 1:
			$msg		= $opts[0];
			break;
		case 2:
			if ( is_array($opts[0]) || is_object($opts[0]) ) {
				$msg	= $opts[0];
				$dump	= $opts[1];
			} else {
				$disc	= $opts[0];
				$msg	= $opts[1];
			}
			break;
		case 3:
			$disc		= $opts[0];
			$msg		= $opts[1];
			$dump		= $opts[2];
			break;	
	}
	
	if (isset($disc) && $disc) {
		$disc = ' \'' . $disc . '\':';
	}
	
	$bt = debug_backtrace();
	$txt = date("Y-M-d H:i:s") 
		. "\t" . $bt[0]['file'] . ':' . $bt[0]['line'] 
		. "\n\n"
		. (isset($disc) ? $disc : '' )
		. "\n"; //add timestamp + file info
	dbug_write($txt);
	if ($dump==1) {//force output via var_dump
		ob_start();
		var_dump($msg);
		$msg=ob_get_contents();
		ob_end_clean();
		dbug_write($msg."\n\n\n");
	} elseif(is_array($msg)||is_object($msg)) {
		dbug_write(print_r($msg,true)."\n\n\n");
	} else {
		dbug_write($msg."\n\n\n");
	}
}

function dbug_write($txt,$check=''){
	$append=false;
	//optionaly ensure that dbug file is smaller than $max_size
	if($check){
		$max_size = 52428800;//hardcoded to 50MB. is that bad? not enough?
		$size = filesize('/tmp/freepbx_debug.log');
		$append = (($size > $max_size) ? false : true );
	}
	if ($append) {
		file_put_contents('/tmp/freepbx_debug.log',$txt);
	} else {
		file_put_contents('/tmp/freepbx_debug.log',$txt, FILE_APPEND);
	}
	
}

function error_handler($errno, $errstr, $errfile, $errline, $errcontext){
	if ($errno == 2048){return;} //keeps out erros related to pear::db
	$error = "\n\n";
	$error .= date("Y-M-d H:i:s").$disc."\t"; //add timestamp
	$error .= $errfile."[".$errline."]\n";
	$error .= 'Error ['.$errno."]: ".$errstr."\n";
	//$error .=  print_r($errcontext)."\n";
	dbug_write($error);
}
?>
